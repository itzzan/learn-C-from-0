#define _CRT_SECURE_NO_WARNINGS 1 
#include <stdio.h>

//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", &i);
//
//	printf("%p\n", &arr[9]);
//
//	for (i = 0; i <= 12; i++)
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}
//
//	return 0;
//}


//整形家族
//浮点型家族
//构造类型 - 自定义类型
//	数组
//	struct 结构体类型
//	enum 枚举
//	union 联合体
//指针类型
// 
//空类型
//void
//函数的返回类型 void test()
//函数参数 void test(void)
//指针 void* p
//
//int main()
//{
//	int arr[10];//int [10]
//	int arr2[5];//int [5]
//
//	return 0;
//}

//int main()
//{
//	int a = -10;
//	//a = -10
//	//10000000000000000000000000001010 - 原码
//	//11111111111111111111111111110101 - 反码
//	//11111111111111111111111111110110 - 补码
//	//内存中放的是16进制，而且是反过来放的
//	//FF FF FF F6
//	return 0;
//}

//数据在内存中以二进制的形式存储
//对于整数来说
//整数的二进制有3种表示形式 - 原码、反码、补码
//正整数：原码、反码、补码相同
//负整数：原码、反码、补码要进行计算
//按照数据的数值直接写出的二进制序列就是原码
//原码的符号位不变，其他位按位取反得到的就是反码
//补码就是反码+1
// 
//整数在内存中存储的是补码


//int main()
//{
//	//1 - 1;（cpu种只有加法器，因此要转换成加法来计算）
//	//1 + (-1);
//	//00000000000000000000000000000001
//	//10000000000000000000000000000001
//	//10000000000000000000000000000010
//	//-2（原码相加，发现是-2，结果有问题，所以不能用原码）
//
//	//00000000000000000000000000000001
//	//11111111111111111111111111111111
//	//100000000000000000000000000000000（放不下，丢了）
//	//00000000000000000000000000000000
//	//0（补码相加，等于0，合适）
//	return 0;
//}

//-1
//10000000000000000000000000000001
//11111111111111111111111111111110
//11111111111111111111111111111111
//（补码要想转换成原码还可以先取反再加一）或减一再取反
//00000000000000000000000000000000
//00000000000000000000000000000001
//


//int main()
//{
//	int a = -10;
//	int b = 10;
//	//b = 10;
//	//00000000000000000000000000001010
//	//0000000A
//
//	//a = -10
//	//10000000000000000000000000001010 - 原码
//	//11111111111111111111111111110101 - 反码
//	//11111111111111111111111111110110 - 补码
//	//内存中放的是16进制，而且是反过来放的
//	//FF FF FF F6
//	return 0;
//}

//大端字节序和小端字节序
//int main()
//{
//	int a = 0x11223344;//小端字节序
//
//	return 0
//}

//请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。

//int main()
//{
//	//写代码判断当前机器的字节序
//	int a = 1;
//	char* p = (char*) & a;//int
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//int check_sys()
//{
//	int a = 1;
//	char* p = &a;
//	if (*p == 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//}


//int check_sys()
//{
//	int a = 1;
//	char* p = &a;
//	return *p;//返回1表示小端，返回0表示大端
//}
//
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//int main()
//{
//	char a = -1;
//	//10000000000000000000000000000001
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111
//	//11111111
//	//整形提升
//	//11111111111111111111111111111111 - 补码
//
//	signed char b = -1;
//	//11111111
//	//11111111111111111111111111111111
//	unsigned char c = -1;
//	//11111111
//	//全是有效数字，无符号位，高位补0
//	//00000000000000000000000011111111
//
//
//	printf("a=%d,b=%d,c=%d", a, b, c);//看原码
//	//-1 -1 255
//	return 0;
//}


//补充
//1. char类型到底是signed char还是unsigned char ?
// C语言标准并没有规定，取决于编译器
// 
//int 是 signed int（C语言规定） 
//short 是 signed short
//

//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000
//	//11111111111111111111111101111111
//	//11111111111111111111111110000000
//	//10000000
//
//	//11111111111111111111111110000000，整形提升是看初始化给的类型
//	//
//	
//	//printf("%u\n", a);//%u是无符号数，所以认为上述就是正的，全是有效数字，无符号位，即补码==原码
//
//	//11111111111111111111111110000000，整形提升是看初始化给的类型
//	//11111111111111111111111101111111
//	//10000000000000000000000010000000
//	printf("%d\n", a);
//	return 0;
//}


//int main()
//{
//	char a = 128;
//	//00000000000000000000000010000000
//	//10000000
//	//11111111111111111111111110000000
//
//	printf("%u\n", a);
//	return 0;
//}


//char类型变量的取值范围
//有符号的char的取值范围：-128~127 - 256个数
//



//int main()
//{
//	int i = -20;
//	//100000000000000000000000000010100
//	//111111111111111111111111111101011
//	//111111111111111111111111111101100
//
//	unsigned int j = 10;
//	//000000000000000000000000000001010
//
//	//111111111111111111111111111110110
//	//111111111111111111111111111110101
//	//100000000000000000000000000001010
//	//-10
//	printf("%d\n", i + j);
//
//	
//
//	return 0;
//}

//int main()
//{
//	unsigned int i;//i在内存中的时候就是看这个类型
//	
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);//而当i被打印的时候，又看%u了，就是如果说是%d，那么就是有符号的整形
//	}//死循环，因为i是unsigned int类型，无符号的，不可能有负数，也就是永远>=0
//
//	return 0;
//}

////int main()
////{
////	char a[1000];
////	int i;
////	for (i = 0; i < 1000; i++)
////	{
////		a[i] = -1 - i;
////	}
////	-1 -2 -3 ... -127 -128 127 126 ... 3 2 1 0 -1 -2 ... -127 -128 127
////	由于char类型只有1个字节，也就是8比特位，也就是8位
////	所以当二进制为11111111在加1的时候，由于只有8位，所以要截断
////	也就是变成了00000000，然后继续+1，所以char类型的范围为—128~127
////	printf("%d", strlen(a));//找到\0，也就是0
////	return 0;
////}


//unsigned char i = 0;//取值范围无符号0-255
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}

#include <limits.h>

//int main()
//{
//	int max;
//
//	return 0;
//}

int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);

	*pFloat = 9.0;
	printf("num的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);

	return 0;
}
